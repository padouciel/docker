{
	Constantes, variables et routines communes à la mise à jour des BD domaines (domain.fdb + event.fdb)
	Doit être include par les scripts spécifiques
}

Const
	// User FB par défaut
	FBUserName='SYSDBA';
	// password FB par défaut
	FBPassword='masterkey';

	// iddem pour les 2 bases
	FB_PAGE_SIZE=16384;
	FB_CHARACTER_SET = csUTF8;
	FB_DIALECT=3;
	

	// Niveaux de logs
	LOG_INFO=0;
	LOG_ERROR=1;
	LOG_DEBUG=2;
	LOG_WARNING=3;

	VER_MAJFB=2;
	VER_MINFB=5;

	cOUTFILE='maj.log';
		
var
	proc_DBDef:String;
	proc_DBDom:String;
	proc_DBEvent:String;

	DataBasePath:String;
	DBPath:String;

	Verbose:Boolean;
	BackupDB:Boolean;


	oFirebird:TFirebird;
	db: TUIBDatabase;
	tr: TUIBTransaction;
	Query : TUIBQuery;
	MetaDB: TMetaDataBase;
	MetaTdf:TMetaTable;

	proc_DBFile:String;

	dummy:String;

	FileConf:string;

	//Caller:String;

	logFile:String;
	outFile: String;

	EventOnly:Boolean;
	DomainOnly:Boolean;


Procedure outputErr(chaine:string);
begin
	try 
		{$IFDEF CONSOLE}
			writelnErr(chaine);
		{$ELSE}
			memo.lines.add(chaine);
		{$ENDIF}
	Except
	End;
End;

Procedure output(chaine:string);
begin
	try 
		{$IFDEF CONSOLE}
			writeln(chaine);
		{$ELSE}
			memo.lines.add(chaine);
		{$ENDIF}
	Except
	End;
End;

{
    Permet d'enregistrer un message de journalisation dans un fichier
    Le script appelant doit avoir initialisé une directive DEBUG pour enregistrer effectivement les messages de niveau DEBUG, ie :
    $DEFINE DEBUG (+ accolades)
    Les niveaux INFO, WARNING et ERROR sont toujours enregistrés
}
procedure logger(msg:string; caller:String; LogLevel:integer; FileLog:String);
var
	level:string;
begin

	// Pas de debug, on sort incondtionnelement si le niveau du message est DEBUG...
	{$IFNDEF DEBUG}
		if LogLevel=LOG_DEBUG then exit;
	{$ENDIF}

	case Loglevel of
		LOG_INFO: level:='[INFO] : ';
		LOG_ERROR: level:='[ERREUR] : '; // Erreur fatale
		LOG_WARNING: level:='[WARNING] : '; // Erreur non fatale
		LOG_DEBUG: level:='[DEBUG] : ';
	Else
		RaiseException(ErTypeMismatch,'Le paramètre level ne peut-être que LOG_INFO (' + intToStr(LOG_INFO) + '), LOG_ERROR (' + intToStr(LOG_ERROR) + '), LOG_WARNING (' + intToStr(LOG_ERROR) + ') ou LOG_DEBUG ' + intToStr(LOG_DEBUG) + ')');
	End;

	// Renvoi une erreur 
	Try
		AppendFichier(
			FormatDateTime('yyyy-mm-dd hh:nn:ss', now)
			+ '  : ' + JustName(FichierScript) + ' - ' + caller + ' : '
			+ level
			+ msg
			+ CRLF,
			FileLog
		);
	Except
		SetExitCode(1);
		RaiseLastException;
	End;
End;

Procedure LogAction(msg:string; caller:String; LogLevel:Integer);
begin
	// Journalisation inconditionnelle fichier...
	if logFile<>'' then
		logger(msg,caller,LogLevel,logFile);

	// Les erreurs sont affichées incondtionnelement sur la console
	if LogLevel=LOG_ERROR then 
		outputErr(msg)
	else
	Begin
		// Pas de debug, on sort incondtionnelement si le niveau du message est DEBUG...
		{$IFNDEF DEBUG}
			if LogLevel=LOG_DEBUG then exit;
		{$ENDIF}
		// Le reste en fonction du verbose
		if Verbose then
			output(msg);
	End;

End;	

function Iif(expr:boolean;IfTrue:Variant ; IfFalse: Variant):Variant;
Begin
	if expr then result := IfTrue Else result := IfFalse;
End;

{
	Renvoie une chaine exprimant une valeur  booléenne
	Si Type = BoolNum (0) : 0/1
	Si Type = BoolStr (1) : True/False
}
Function BoolToStr(Val:Boolean;RetType:Integer):String;
Begin
	case RetType of
		0: Result:=iif(Val,'1','0');
		1: Result:=iif(Val,'True','False');
	Else
		RaiseException(ErTypeMismatch,'Le paramètre RetType ne peut-être que 0 (numérique : 0/1) ou 1 (texte : True/False))');
	End;
End;

Function GetDefConfigNASFile():String;
Begin
	{$IFDEF LINUX}
		Result:= '/etc/opt/novaappserver/novaappserver.conf';
	{$ELSE}
		Result:= GetPgmDataDirectory+'NovaAppserver\novaappserver.conf';
	{$ENDIF}
End;

procedure UsageMAJ();
Var
	Caller:String;
begin
	Caller:='UsageMAJ';
	outputErr(
		CRLF + 'Vous devez appeler ce script de la manière suivante : ' + CRLF +
		paramstr(0) + ' ' + paramstr(1) + CRLF + CRLF +
		'Les paramètres suivants sont disponibles :' + CRLF + 
			'	[-c "Path accès au fichier de configuration NAS" (' + GetDefConfigNASFile + ' par défaut - permet de rechercher automatiquement le path d''accès à la base de données, l''utilisateur et le mot de passe Firebird dans un fichier de configuration NAS situé sur CETTE machine {les options -d, -u et -p sont prioritaires sur cette option})]' + CRLF + 
			'	[-d "Path accès base de données" (' + iif(DataBasePath='','Pas de chemin d''accès',DataBasePath) + ' par défaut - permet de préciser explicitement le path d''accès à la base de données {prioritaire même si l''option -c est passée})]' + CRLF + 
			'	[-f "Path fichier recréation des procédures + Triggers + vues + etc." (' + ExtractFilepath(FichierScript) + proc_DBDef + ' par défaut)]' + CRLF + 
			'	[-u "Utilisateur Firebird" (' + FBUserName + ' par défaut {prioritaire même si l''option -c est passée})]' + CRLF + 
			'	[-p "password Firebird" (' + FBPassword + ' par défaut) - passer une chaine vide "" si aucun mot de passe n''est  nécessaire {prioritaire même si l''option -c est passée}]' + CRLF + 
			'	[-b (bavard : ' + BoolToStr(Verbose,1) + ' par défaut)]' + CRLF +
			'	[-l "Path fichier journalisation (log)" (Journalisation fichier : ' + iif(logFile='','Pas de journalisation', logFile)  + ' par défaut) -  - passer une chaine vide "" pour ne PAS journaliser dans un fichier]' + CRLF +
			'	[-s (Sauvegarde : ' + BoolToStr(BackupDB,1) + ' par défaut) - Ne PAS effectuer une sauvegarde préalablement à l''application du script (dans le même répertoire que celui de la base de données originale et sous le nom "' + iif(DataBasePath='','NomBaseOriginale',ExtractFileName(DataBasePath)) + '_before_V_XXX.fbk où XXX est la version cible)]' + CRLF
	);
end;

procedure UsageCreate();
Var
	Caller:String;
begin
	Caller:='UsageCreate';
	outputErr(
		CRLF + 'Vous devez appeler ce script de la manière suivante : ' + CRLF +
		paramstr(0) + ' ' + paramstr(1) + CRLF + CRLF +
		'Les paramètres suivants sont disponibles :' + CRLF + 
			'	[-d "Répertoire/Dossier emplacement de(s) base(s) de données" (' + iif(DBPath='','Pas de chemin d''accès',DBPath) + ' par défaut - permet de préciser explicitement le path d''accès à la base de données)]' + CRLF + 
			'	[-e (Base de données event seulement (' + BoolToStr(EventOnly,1) + ' par défaut - Création de la base données "event" seulement)]' + CRLF + 
			'	[-m (Base de données domain seulement (' + BoolToStr(DomainOnly,1) + ' par défaut - Création de la base données "domain" seulement)]' + CRLF + 
			'	[-f "Path fichier SQL création Base de données domain" (' + proc_DBDom + ' par défaut)]' + CRLF + 
			'	[-c "Path fichier SQL création Base de données event" (' + proc_DBEvent + ' par défaut)]' + CRLF + 
			'	[-u "Utilisateur Firebird" (' + FBUserName + ' par défaut )]' + CRLF + 
			'	[-p "password Firebird" (' + FBPassword + ' par défaut) - passer une chaine vide "" si aucun mot de passe n''est  nécessaire]' + CRLF + 
			'	[-b (bavard : ' + BoolToStr(Verbose,1) + ' par défaut)]' + CRLF +
			'	[-l "Path fichier journalisation (log)" (Journalisation fichier : ' + iif(logFile='','Pas de journalisation', logFile)  + ' par défaut) -  - passer une chaine vide "" pour ne PAS journaliser dans un fichier]' + CRLF
	);
end;

{
	Renvoie une chaine vide si la base cible n'est accedée que par nous...
	Sinon renvoie une chaine contenant la liste des process attachés à la db, par exemple :
Liste des processus (autres que le script de MAJ en cours) qui utilisent actuellement la base de données : 
  ID USER                            REMOTE_ADDRESS       PROCESS                                           
  39 SYSDBA                          127.0.0.1            /usr/bin/flamerobin                               
  35 SYSDBA                          192.168.1.11         C:\Program Files\Firebird\Firebird\bin\isql.exe   
}
Function GetExclDbAtt():string;
var
	NbAtt:Integer;
	FmtSync:String;
	LstData:String;
	Caller:String;


Begin
	Caller:='GetExclDbAtt';
	LogAction('Vérification de l''accès exclusif à la base de données',Caller,LOG_INFO);

	Try
		Query.SQL.Text := 'SELECT count(MON$ATTACHMENT_ID) FROM MON$ATTACHMENTS';
		Query.Open(true);
		NbAtt:=Query.Fields.AsInteger[0];
		if NbAtt=1 then // Que nous même...
		Begin
			Result:='';
			Exit;
		End;

		// On donne du détail
		Query.SQL.Text := 'SELECT MON$ATTACHMENT_ID, MON$USER, MON$REMOTE_ADDRESS, MON$REMOTE_PROCESS FROM MON$ATTACHMENTS';
		Query.Open(true);

		FmtSync:='%4s %-31.31s %-20.20s %-50.50s';
		LstData:=format(FmtSync, ['ID','USER','REMOTE_ADDRESS','PROCESS']) + CRLF;

		while not Query.EOF do
		begin
			// On exclue le script en cours... TODO Vérifier avec des appels différents...
			if CompareText(trim(Query.Fields.AsString[3]),paramstr(0))<>0  then 
				LstData:=LstData + format(FmtSync, [Trim(Query.Fields.AsString[0]),Trim(Query.Fields.AsString[1]),Trim(Query.Fields.AsString[2]),Trim(Query.Fields.AsString[3])]) + CRLF;
			Query.Next;
		end;
		Result:=LstData;

	Finally
		Query.Close(etmCommit);
	End;

End;


{
	Ici on fait :
	- Initialisaiton des variables globales
	- Récupération des paramètres dans un fichier de configuration (si accessible et/ou passé en paramètre)
	- Récupératin des paramètres passé en ligne de commande
	- Test d'accès sur la bd cible
	- Test d'accès exculsif sur la bd cible

Donc, quand si on sort d'ici en True on est censé pouvoir travailler sur la bd cible et y effectuer les traitements associés...
}
Function GetParamsMAJ(Prefix:String):boolean;
var
	lConf:TstringList;
	VerFB:String;
	i:Integer;
	Caller:String;


Begin
	Caller:='GetParamsMAJ';
	Result:=true;

	// Init des variables globales
	oFirebird:=TFirebird.create;

	// Les paramètres par défaut...
	oFirebird.user:=FBUserName;
	oFirebird.pwdCrypted:='';
	oFirebird.pwd:=FBPassword;

//     db.databasename :=DataBasePath;
	proc_DBFile:=ExtractFilepath(FichierScript) + proc_DBDef;
	BackupDB:=True;

	LogAction('Nombre de paramètres passés :' + Int64ToStr(paramcount),Caller,LOG_DEBUG);

	// Dans un premier temps, on essaie de récupérer les informations dans un fichier de conf

	// Si un fichier de conf est spécifié, on vérifie sa présence
	if FindCmdLineSwitch('c', dummy, True) then
	Begin
		if not FileExists(dummy) then
		Begin
			RaiseException(erCustomError,
				'Impossible de localiser le fichier de configuration du serveur NAS "' + dummy + '" sur la machine locale !'
// 				'Impossible de déterminer le chemin d''accès de la base de données à mettre à jour ; veuillez le préciser manuellement à l''aide de l''option "-d"' + CRLF +
// 				'Lancez "' + paramstr(0) + ' ' + paramstr(1) + ' -H" pour obtenir de l''aide sur les options disponibles pour ce script)'
			);
			exit;
		End
		Else
			FileConf:=dummy;
	End
	Else
		// On essaie avec le fichier par défaut
		FileConf:=GetDefConfigNASFile;

	// On essaie de lire les informations dans ce fichier s'il est présent (sinon, on ne fait rien silencieusement)
	if FileExists(FileConf) then
	Begin
		try		
			lConf:=TstringList.create;
			lConf.loadFromFile(FileConf);

			// Path DB
			DataBasePath:=lconf.values[UpperCase(Prefix)+'_DATABASE_URL'];

			//utilisateur FIREBIRD
			oFirebird.user:=lconf.values['DBUSER'];

			//#mot de passe de l'utilisateur FIREBIRD
			oFirebird.pwdCrypted:=lconf.values['DBPASSWORD'];
			oFirebird.pwd:='';

		finally
			if Lconf<>Nil then Lconf.free;
		End;
	End;

	// Dans un second temps prise en charge des paramètres passés (qui remplacent les valeurs par défaut ou celles récupérées dans le fichier de configuration)
	if FindCmdLineSwitch('u', dummy, True) then oFirebird.user:=dummy;
		
	if FindCmdLineSwitch('p', dummy, True) then 
	begin
		oFirebird.pwdCrypted:=''; 
		oFirebird.pwd:=dummy;
	end;

	if FindCmdLineSwitch('f', dummy, True) then proc_DBFile:=dummy;

	if FindCmdLineSwitch('b', dummy, False) then Verbose:=true;

	// Inconctionnel dans ce cas
	{$IFDEF DEBUG} Verbose:=True {$ENDIF}

	if FindCmdLineSwitch('s', dummy, False) then BackupDB:=False;

	if FindCmdLineSwitch('d', dummy, True) then DataBasePath:=dummy;

	logFile:=IncludeTrailingPathDelimiter(ExtractFilepath(FichierScript)) + JustName(FichierScript)+'.log';
	if FindCmdLineSwitch('l', dummy, True) then logFile:=trim(dummy);
	outFile := ExtractFilepath(logFile) + cOUTFILE;

	LogAction(
	'Liste des paramètres après GetParams :' + CRLF +
	'	-d (DataBasePath) : ' + DataBasePath + CRLF +
	'	-f (proc_DBFile) : ' + proc_DBFile + CRLF +
	'	-b (Verbose) : ' + BoolToStr(Verbose,1 ) + CRLF +
	'	-l (logfile) : ' + iif(logFile='','Pas de journalisation', logFile) + CRLF +
	'	-s (BackupDB) : ' + BoolToStr(BackupDB,1 ) + CRLF +
	'	-u (oFirebird.user) : ' + oFirebird.user + CRLF +
	'	-p (oFirebird.pwdCrypted) : ' +oFirebird.pwdCrypted + ' OU (oFirebird.pwd)  : ' + oFirebird.pwd + CRLF +
	'	-c (FileConf) : ' + FileConf
	,Caller,LOG_DEBUG);

	if FindCmdLineSwitch('H', dummy, False) then 
	begin
		UsageMAJ;
		Result:=False;
		Exit;
	end;

	// On tente une journalisation
	if logfile<>'' then
	Begin
		logger('=====================================================================================================',Caller,LOG_INFO,logFile);
		logger('Lancement de la procédure de Mise à jour',Caller,LOG_INFO,logFile);
	End;
	LogAction('Traitement des paramètres...',Caller,LOG_INFO);

	// Si le path bd n'est pas initialisée après la récupération des paramètres (pas de chemin par défaut), on ne peut pas travailler...
	if DataBasePath='' then
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,'Aucune base de données à mettre à jour n''a pu être trouvée (option "-d" non passée ou paramètre "' + UpperCase(Prefix)+'_DATABASE_URL' + '" non trouvé dans le fichier "' + FileConf + '", ce dernier fichier pouvant ne pas exister sur ce système)');
	End;

	if Not FileExists(proc_DBFile) then
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,'Le fichier de reconstruction des procédures + Triggers + vues + etc "' +  proc_DBFile + '" (cf. option "-f") n''a pas pu être trouvé...');
	End;

	// On tente une première connexion pour vérifier que les paramètres d'accès soient Ok...
	LogAction('Connexion sur la base de données : "' + DataBasePath + '"',Caller,LOG_INFO);
	Try
		oFirebird.open(DataBasePath);
		db := oFirebird.db;
		db.CharacterSet := FB_CHARACTER_SET;
		db.SQLDialect := FB_DIALECT;

		tr := TUIBTransaction.create(nil);
		MetaDB := TMetaDataBase.Create(nil, 0);
		tr.database := db;
		Query := TUIBQuery.create(nil);
		Query.transaction := tr;
		// On lance tout de suite une requête de test (pas d'erreur d'accès avant !!!)
		Query.SQL.Text := 'SELECT 1 FROM RDB$DATABASE';
		Query.Open(true);
		
	Except
		SetExitCode(1);
		RaiseException(erCustomError,'Impossible d''ouvrir à la base de données "' + DataBasePath + '" : '
			+ CRLF + '	' + ExceptionParam +
			iif(trim(oFirebird.errmsg)<>'', CRLF + '	' + oFirebird.errmsg,''));
	End;

	//LogAction('Version Library : "' + Db.LibraryName+ '"',Caller,LOG_INFO);
	//LogAction('Version Firebird Min : "' + Int64ToStr(Db.InfoSvrMinVer)+ '"',Caller,LOG_INFO); // <== inconnue...

	
	// Version FB nécessaire BD Domaine : >= 2.5
	// Win : "WI-V2.5.2.26540 Firebird 2.5" / Linux : "LI-V2.5.2.26539 Firebird 2.5"
	// Test des versions serveurs (TODO : voir pb JMB DLL cliente 2.1/Serbeur 2.5)
	LogAction('Version Firebird complète: "' + Db.InfoFirebirdVersion + '"',Caller,LOG_DEBUG);
	VerFB:=Trim(Copy(Db.InfoFirebirdVersion,pos('Firebird', Db.InfoFirebirdVersion)+9,Length(Db.InfoFirebirdVersion)));
	LogAction('Version MAJ.MIN Firebird : "' + VerFB + '"',Caller,LOG_DEBUG);
	lconf:=SplitStr(VerFB,'.');
	
	// short circuit evaluation Ok (cf. http://www.freepascal.org/docs-html/ref/refsu41.html#x131-14100012.8.3)
	LogAction('Vérification de la compatibilité de la version du serveur Firebird (version reconnue : ' + VerFB + ')',Caller,LOG_INFO);
	if (StrToInt(lconf[0])<VER_MAJFB) or (StrToInt(lconf[1])< VER_MINFB) then
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,'La version du serveur Firebird est inférieure à celle requise par cette procédure (version serveur détectée : ' + VerFB + ' vs version minimale attendue ' + intToStr(VER_MAJFB) + '.' + intToStr(VER_MINFB) + ')');
	End;

	// TODO : Test version cliente si applicable à terme ...

	// Test de l'accès "Exclusif" à la base de données
	dummy:=GetExclDbAtt;

	if dummy<>'' then
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,
			'Impossible d''effectuer la mise à jour car la base de données "' + DataBasePath + '" est actuellement utilisée par d''autre(s) processus' + CRLF +
			'Vous devez avoir un accès exclusif à la base de données pendant le déroulement de cette procédure' + CRLF +
			'Liste des processus (autres que le script de MAJ en cours) qui utilisent actuellement la base de données : ' + CRLF +  dummy
			);
	End;

	//2°) Mise à jour des métadonnées
	LogAction('Chargement de la base de données',Caller,LOG_INFO);
	MetaDB.LoadFromDatabase(tr);
	tr.Commit;
	LogAction('Fin de Get_config',Caller,LOG_DEBUG);

End;

{
	Ici on fait :
	- Initialisaiton des variables globales
	- Récupératin des paramètres passé en ligne de commande

	Donc, quand si on sort d'ici en True on est censé pouvoir travailler sur la bd cible et y effectuer les traitements associés...
}
Function GetParamsCreate():boolean;
var
	i:Integer;
	Caller:String;


Begin
	Caller:='GetParamsCreate';
	Result:=true;

	// Init des variables globales
	oFirebird:=TFirebird.create;

	// Les paramètres par défaut...
	oFirebird.user:=FBUserName;
	oFirebird.pwd:=FBPassword;

	LogAction('Nombre de paramètres passés :' + Int64ToStr(paramcount),Caller,LOG_DEBUG);

	// Dans un second temps prise en charge des paramètres passés (qui remplacent les valeurs par défaut ou celles récupérées dans le fichier de configuration)
	if FindCmdLineSwitch('u', dummy, True) then oFirebird.user:=dummy;
		
	if FindCmdLineSwitch('p', dummy, True) then 
	begin
		oFirebird.pwd:=dummy;
	end;

	proc_DBDom:=ExtractFilepath(FichierScript) + proc_DBDom;
	if FindCmdLineSwitch('f', dummy, True) then proc_DBDom:=dummy;

	proc_DBEvent:=ExtractFilepath(FichierScript) + proc_DBEvent;
	if FindCmdLineSwitch('c', dummy, True) then proc_DBEvent:=dummy;

	LogAction('proc_DBDom : "' + proc_DBDom + '"' + CRLF + 'proc_DBEvent : "' + proc_DBEvent + '"' ,Caller,LOG_DEBUG);

	if FindCmdLineSwitch('b', dummy, False) then Verbose:=true;

	// Inconctionnel dans ce cas
	{$IFDEF DEBUG} Verbose:=True {$ENDIF}

	// Path par défaut
	DBPath:=IncludeTrailingPathDelimiter(DBPath);

	if FindCmdLineSwitch('d', dummy, True) then DBPath:=dummy;

	if FindCmdLineSwitch('e', dummy, False) then EventOnly:=True;

	if FindCmdLineSwitch('m', dummy, False) then DomainOnly:=True;

	logFile:=IncludeTrailingPathDelimiter(ExtractFilepath(FichierScript)) + JustName(FichierScript)+'.log';
	if FindCmdLineSwitch('l', dummy, True) then logFile:=trim(dummy);
	outFile := ExtractFilepath(logFile) + cOUTFILE;

	LogAction(
	'Liste des paramètres après GetParams :' + CRLF +
	'	-d (DataBasePath) : ' + DBPath + CRLF +
	'	-f (proc_DBDom) : ' + proc_DBDom + CRLF +
	'	-c (proc_DBEvent) : ' + proc_DBEvent + CRLF +
	'	-b (Verbose) : ' + BoolToStr(Verbose,1 ) + CRLF +
	'	-l (logfile) : ' + iif(logFile='','Pas de journalisation', logFile) + CRLF +
	'	-u (oFirebird.user) : ' + oFirebird.user + CRLF +
	'	-p (oFirebird.pwd)  : ' + oFirebird.pwd + CRLF +
	'	-e (event only)  : ' + BoolToStr(EventOnly,1) + CRLF +
	'	-m (domain only)  : ' + BoolToStr(DomainOnly,1)
	,Caller,LOG_DEBUG);

	if FindCmdLineSwitch('H', dummy, False) then 
	begin
		UsageCreate;
		Result:=False;
		Exit;
	end;

	// On tente une journalisation
	if logfile<>'' then
	Begin
		logger('=====================================================================================================',Caller,LOG_INFO,logFile);
		logger('Lancement de la procédure de création',Caller,LOG_INFO,logFile);
	End;
	LogAction('Traitement des paramètres...',Caller,LOG_INFO);

	// Si le path bd n'est pas initialisée après la récupération des paramètres (pas de chemin par défaut), on ne peut pas travailler...
	if not DirectoryExists(DBPath) then
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,'Le répertoire "' + DBPath + '" n''existe pas...');
	End;

	LogAction('Fin de ' + Caller,Caller,LOG_DEBUG);

End;

Procedure FreeRes();
Begin
	if MetaDB<>nil then MetaDB.free;
	if Query<>nil then Query.free;
	if tr<>nil then tr.free;
//	if db<>nil then db.free();
	if oFirebird<>nil then oFirebird.free;   
End;

procedure FinMAJ(msg:string);
Begin
	if not AppendFichier(msg + CRLF, outFile) then
	Begin
		SetExitCode(1);
		Output('Impossible d''écrire dans le fichier "' + outFile);
		exit;
	End;
End;


{
	Fonctions outils SQL
}

Function RunSQLScriptFile(FichierSQL:string):Boolean;
var
    RunScript: TRunScriptSQL;
	Caller:String;
begin
	Caller:='RunSQLScriptFile';

	LogAction('Exécution de script SQL...',Caller,LOG_DEBUG);

	Result:=True;

	RunScript := TRunScriptSQL.Create(db,true);
	RunScript.StopOnError:=True;

	If Verbose then
	begin
		RunScript.ShowParse:=true;
		{$IFNDEF CONSOLE}
			RunScript.Memo:=Memo;
		{$ENDIF}
	end;

  RunScript.lines.loadFromFile(FichierSQL);
 
	RunScript.Run;

	if RunScript.errmsg<>'' then
	Begin
		Result:=False;
		LogAction('Erreur lors de l''exécution du script SQL :' + CRLF + RunScript.errmsg,Caller,LOG_ERROR);
	End;

	if RunScript<>nil then RunScript.Free();

end;

Function RunSQLScript(SQLScript:TStringList):Boolean;
var
    RunScript: TRunScriptSQL;
	Caller:String;
begin
	Caller:='RunSQLScript';

	LogAction('Exécution de script SQL...',Caller,LOG_DEBUG);

	Result:=True;

	RunScript := TRunScriptSQL.Create(db,true);
	RunScript.StopOnError:=True;

	If Verbose then
	begin
		RunScript.ShowParse:=true;
		{$IFNDEF CONSOLE}
			RunScript.Memo:=Memo;
		{$ENDIF}
	end;

	RunScript.lines.text:=SQLScript.text; 
	RunScript.Run;

	if RunScript.errmsg<>'' then
	Begin
		Result:=False;
		LogAction('Erreur lors de l''exécution du script SQL :' + CRLF + RunScript.errmsg,Caller,LOG_ERROR);
	End;

	tr.Commit;

	if RunScript<>nil then RunScript.Free();

end;

function RunSQLFile(FichierSQL:string):Boolean;
var
  FileContents:TStringList;
	Caller:String;
begin
	Caller:='RunSQLFile';

	//FileContents:=TStringList.create();

	LogAction('Exécution du fichier script : "' + FichierSQL + '"',Caller,LOG_INFO);

	//FileContents.loadFromFile(FichierSQL);
	//Result:=RunSQLScript(FileContents);
 Result:=RunSQLScriptFile(FichierSQL);

	if FileContents<>Nil then FileContents.Free();

end;

Function ExecuteSQL(cSQL:string):Int64;
var
	Caller:String;

begin
	Caller:='ExecuteSQL';
	LogAction('Exécution commande SQL :' + CRLF + chr(9) + cSQL,Caller,LOG_DEBUG);

    Query.SQL.clear;    
    Query.SQL.Add(cSQL);
//	Query.ExecSQL;
	Query.Open(True);
	Result:=Query.RowsAffected;
	LogAction('Nb enregistrements impactés : ' + Int64ToStr(Result), Caller,LOG_DEBUG);
    Query.Close(etmCommit);
	LogAction('Exécution commande OK',Caller,LOG_DEBUG);
end;

{
	Funciton spécifique à la  MAJ de Metadata (Table, index, etc.)
	On rafraichi les Meta FB après chaque Exécution...
}
Function MAJMeta(cSQL:String):Int64;
var
	Caller:String;

begin
	Caller:='MAJMeta';
	LogAction('MAJ MetaData Firebird :' + CRLF + chr(9) + cSQL,Caller,LOG_DEBUG);

	// On lance la commande SQL normalement...
	Result:=ExecuteSQL(cSQL);

	// On rafraichit les Meta...
	MetaDB.LoadFromDatabase(tr);
	tr.Commit;
End;


Procedure PurgeProcStock;
var
	Caller:String;
begin
	Caller:='PurgeProcStock';
	LogAction('Suppression des Procédures stockées et views...',Caller,LOG_INFO);

	{Les dépendances}
	// DELETE des dépendances non système et basées sur VIEWS/TRIGGERS/PROC 
    ExecuteSQL(
		'DELETE FROM RDB$DEPENDENCIES WHERE RDB$DEPENDED_ON_TYPE IN (1,2,5) AND (RDB$DEPENDED_ON_NAME IN (SELECT RDB$PROCEDURE_NAME FROM RDB$PROCEDURES PS WHERE PS.RDB$SYSTEM_FLAG=0) OR RDB$DEPENDED_ON_NAME IN (SELECT RDB$RELATION_NAME FROM RDB$RELATIONS RV WHERE RV.RDB$SYSTEM_FLAG=0 AND RV.RDB$RELATION_TYPE IN(1,2)))'
	);

	{Les views}
	// Sauvegarde des noms de views
    ExecuteSQL(
		'CREATE GLOBAL TEMPORARY TABLE VIEW_NAMES (RDB$RELATION_NAME CHAR(31)) ON COMMIT PRESERVE ROWS;'
	);   
    ExecuteSQL(
		'INSERT INTO VIEW_NAMES SELECT RDB$RELATION_NAME FROM RDB$RELATIONS RV WHERE RV.RDB$SYSTEM_FLAG=0 AND RV.RDB$RELATION_TYPE=1'
	);   
	// DELETE des views
	ExecuteSQL(
		'DELETE FROM RDB$RELATIONS RV WHERE RV.RDB$SYSTEM_FLAG=0 AND RV.RDB$RELATION_TYPE=1'
	);   
	// DELETE des colonnes de views
    ExecuteSQL(
		'DELETE FROM RDB$RELATION_FIELDS WHERE RDB$SYSTEM_FLAG=0 AND (RDB$RELATION_NAME IN (SELECT RDB$RELATION_NAME FROM VIEW_NAMES) OR RDB$RELATION_NAME NOT IN (SELECT RDB$RELATION_NAME FROM RDB$RELATIONS))'
	);

    ExecuteSQL(
		'DROP TABLE VIEW_NAMES;'
	);

    ExecuteSQL(
		'DELETE FROM RDB$VIEW_RELATIONS' // Table obsolète (d'après The Firebird Book), mais peuplée ==> ???
	);   

    {Les PS}
    ExecuteSQL(
		'DELETE FROM RDB$PROCEDURE_PARAMETERS WHERE RDB$PROCEDURE_NAME IN (SELECT RDB$PROCEDURE_NAME FROM RDB$PROCEDURES PS WHERE PS.RDB$SYSTEM_FLAG=0)'
	);
    ExecuteSQL(
		'DELETE FROM RDB$PROCEDURES WHERE RDB$SYSTEM_FLAG=0'
	);

	// Les TRIGGERS sont supprimés APRÈS MAJ des datas par une autre procédure "PurgeTriggers"...

end;

Procedure PurgeTriggers;
var
	Caller:String;
begin
	Caller:='PurgeTriggers';
	LogAction('Suppression des Triggers...',Caller,LOG_INFO);
    {Les triggers}
	// Attention, les contraintes "Check" sont considérés comme des triggers système (RDB$SYSTEM_FLAG=3) et doivent donc être traités spécifiquement...
    ExecuteSQL(
		'DELETE FROM RDB$TRIGGERS WHERE RDB$SYSTEM_FLAG=0' //RDB$TRIGGER_TYPE=17 ==> Tous les triggers ne sont pas forcément en 17 ???
	);
End;


Procedure RecreateIndex;
var
	Caller:String;
	SQL:TStringList;
begin
	Caller:='RecreateIndex';
	LogAction('Réinitialisation des index...',Caller,LOG_INFO);
	
	SQL:=TStringList.Create();

	SQL.Text:=//'set term ^ ; ' + 
	'EXECUTE BLOCK AS ' +
	'declare variable index_name VARCHAR(31); ' +
	'declare variable index_system smallint; ' +
	'BEGIN ' + 
	'	for select RDB$INDEX_NAME,iif(RDB$UNIQUE_FLAG=0 AND RDB$FOREIGN_KEY is null,0,1) from RDB$INDICES where RDB$SYSTEM_FLAG=0 into :index_name, :index_system do ' + 
	'	Begin ' +
	'		if (:index_system=1) then ' + 
	'			execute statement ''SET statistics INDEX  '' || index_name || '';'' ;' + 
	'		else ' +
	'		Begin ' + 
	'			execute statement ''ALTER INDEX '' || index_name || '' inactive;'' ;' +
	'			execute statement ''ALTER INDEX '' || index_name || '' active;'' ;' +
	'		End ' +
	'	End ' +
	'END ; ';// + 
//	'set term ; ^';

	if not RunSQLScript(SQL) then 
	Begin
		SetExitCode(1);
		RaiseException(erCustomError,
			'Erreur lors de l''application du script de recréation des index'
		);
	End;

	if SQL<>Nil then SQL.Free();
End;


{
	Backup d'une db
}
Function DBBackup(db: TUIBDatabase; version:Integer):Boolean;
var
	UIBBackup: TUIBBackup;
	sepURL:Integer;
	host:string;
	Caller:String;
	
Begin
	Caller:='DBBackup';
	Result:=false;

	LogAction('Sauvegarde de la base de données',Caller,LOG_INFO);

	UIBBackup:=TUIBBackup.Create(Nil);

	if oFirebird.host='embed' then
		UIBBackup.host:=''
	else
	begin            
	{
	sepURL:=pos(':',db.databasename);
		host:=trim(copy(db.databasename,1,sepURL-1));
	}  
		UIBBackup.host:= oFirebird.host;
	End;
    
	LogAction('Host : "' + UIBBackup.host + '"',Caller,LOG_DEBUG);


	UIBBackup.LibraryName:=db.LibraryName;
//	LogAction('db.libraryName : ' + db.LibraryName,Caller,LOG_DEBUG);

	UIBBackup.Database := oFirebird.path+oFirebird.Filename;

	UIBBackup.UserName := db.username;
	UIBBackup.PassWord := db.password;
	// Chaque fichier de backup porte un nom unique...
	UIBBackup.BackupFiles.Text := UIBBackup.Database + '_before_V_' + Int64ToStr(version) + '_'+ FormatDateTime('yyyymmdd_hhnnss',Now) + '.fbk';

	if (UIBBackup.host='') or (UIBBackup.host='local') then
		UIBBackup.Protocol:=proLocalHost
	Else
		UIBBackup.Protocol:=proTCPIP;

	// Ceci doit toujours être True pour avoir une exception si le backup échoue (c'est une logique Pascalienne ;-)
	UIBBackup.Verbose:=True;

	// Inutile si distant....
// 	if FileExists(trim(UIBBackup.BackupFiles.Text)) then
// 		RaiseException(erCustomError,
// 			'Un fichier de sauvegarde "' + trim(UIBBackup.BackupFiles.Text) + '" existe déjà, merci de le renommer ou le supprimer s''il n''est plus utile...'
// 		);

	LogAction('Host : "' + UIBBackup.host + '"  - Database : "' + UIBBackup.Database + '" - Library : "' + UIBBackup.LibraryName + '"',Caller,LOG_DEBUG);


// 	if cbLocalHost.Checked then
// 		UIBBackup.Protocol := proTCPIP else
// 		UIBBackup.Protocol := proLocalHost;
	LogAction('Lancement de la sauvegarde de "' + UIBBackup.Database + '" vers "' + trim(UIBBackup.BackupFiles.Text) + '"',Caller,LOG_INFO);
	try
		UIBBackup.Run;
		Result:=True;
	Except
		SetExitCode(1);
		RaiseException(erCustomError,'Erreur lors de la sauvegarde de "' + UIBBackup.Database + '" vers "' + trim(UIBBackup.BackupFiles.Text) + '"' + CRLF + ExceptionParam);
	Finally
		UIBBackup.free();
	End;

End;


{
	Functiosn outils MAJ
}
  
function TableExists(const Name: string):boolean;
var
	Caller:String;
begin
	Caller:='TableExist';
	LogAction('Vérification de la présence de la table "' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	if MetaDB.FindTableName(Name)<>nil then
		Result:=True;
end;
  
  
function FieldExists(const Table:TMetaTable; Name: string):boolean;
var
	I: Integer;
	Caller:String;
begin
	Caller:='FieldExists';
	LogAction('Vérification de la présence de la colonne "' + Table.name + '.' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	for I := 0 to Table.FieldsCount - 1 do
	if Table.Fields[I].Name = Name then
	begin
		LogAction('	Colonne trouvée...',Caller,LOG_DEBUG);
		Result := True;
		Exit;
	end;
	LogAction('	Colonne non trouvée...',Caller,LOG_DEBUG);
end;

function RecordExists(const SQL:String):boolean;
var
	Caller:String;
Begin
	Caller:='RecordExists';
	LogAction('Vérification de la présence d''un enregistrement "' + SQL + '"',Caller,LOG_DEBUG);
	Query.SQL.clear;    
    Query.SQL.Text:=SQL;
	try
		Query.open(true);
		// Retourne True si on est pas sur le dernier enregistrement...
		Result:=not Query.eof;

	Except
		OutputErr('Erreur lors de l''exécution d''une requête RecordExists');
		RaiseLastException;
	Finally
		Query.Close(etmCommit);
	End;
end;


function ForeignExists(const Table:TMetaTable; Name: string):boolean;
var
	I: Integer;	
	Caller:String;
begin
	Caller:='ForeignExists';
	LogAction('Vérification de la présence de la clé étrangère "' + Table.name + '.' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	for I := 0 to Table.ForeignCount - 1 do
	Begin
		//LogAction('clé étrangère ' + Int64ToStr(i+1) + '/' + Int64ToStr(Table.ForeignCount) + ' "' + Table.Foreign[I].Name + '"',Caller,LOG_DEBUG);

		if Table.Foreign[I].Name = Name then
		begin
			Result := True;
			LogAction('Clé étrangère "' + Name + '" existe...',Caller,LOG_DEBUG);
			Exit;
		end;
	end;
	LogAction('Clé étrangère "' + Name + '" n''existe pas...',Caller,LOG_DEBUG);
end;


function IndexExists(const Table:TMetaTable; Name: string):boolean;
var
	I: Integer;
	Caller:String;
begin
	Caller:='IndexExists';
	LogAction('Vérification de la présence de l''index "' + Table.name + '.' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	for I := 0 to Table.IndicesCount - 1 do
	Begin
		if Table.Indices[I].Name = Name then
		begin
			Result := True;
			LogAction('Index "' + Name + '" existe...',Caller,LOG_DEBUG);
			Exit;
		end;
	End;
	LogAction('Index "' + Name + '" n''existe pas...',Caller,LOG_DEBUG);
end;

function GeneratorExists(const Name: string):boolean;
var
	Caller:String;
begin
	Caller:='GeneratorExists';
	LogAction('Vérification de la présence du générateur "' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	if MetaDB.FindGeneratorName(Name)<>nil then
		Result:=True;
end;

function ExceptionExists(const Name: string):boolean;
var
	Caller:String;
begin
	Caller:='ExceptionExists';
	LogAction('Vérification de la présence de l''exception "' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	if MetaDB.FindExceptionName(Name)<>nil then
		Result:=True;
end;

function DomainExists(const Name: string):boolean;
var
	Caller:String;
begin
	Caller:='DomainExists';
	LogAction('Vérification de la présence du domaine "' + Name + '"',Caller,LOG_DEBUG);
	result:=False;
	if MetaDB.FindDomainName(Name)<>nil then
		Result:=True;
end;
