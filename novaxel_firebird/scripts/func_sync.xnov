
{$I func_nas.xnov}

// Include des constantes d'authentification admin PROPRES au site (ne pas synchroniser ce fichier en prod...)
{$I local_auth.xnov}

const

	// email admin par défaut si aucun email n'est déclaré en TDOMPARAM
	ADMIN_MAIL='root@localhost';
	// Adresse utilisée en From si non trouvé en TDOMPARAM
	MAIL_FROM='root'; // ==> Ajouter GetHostname en fin lors de l'utilisation...

	//Déilimiteur utilisé dans les sujets/cors d'email pour délimiter les variables à parser...
	// ATTENTION : Les TDOMPARAM correspondant doivent utiliser les mêmes délimiteur...
	VAR_MAIL_DELIM='%%';

	//Paramètres domaine à récupérer pour les email :
	DOM_ADMIN_EMAIL_S='DOMAIN';DOM_ADMIN_EMAIL_N='ADMIN_EMAIL';
	SYNC_MAILADMIN_OK_S='SYNCHRO';SYNC_MAILADMIN_OK_N='EMAIL_OK_ADMIN';
	SYNC_MAILADMIN_KO_S='SYNCHRO';SYNC_MAILADMIN_KO_N='EMAIL_KO_ADMIN';
	SYNC_MAILOWNER_OK_S='SYNCHRO';SYNC_MAILOWNER_OK_N='EMAIL_OK_OWNER';
	SYNC_MAILOWNER_KO_S='SYNCHRO';SYNC_MAILOWNER_KO_N='EMAIL_KO_OWNER';
	DOM_SIG_MAIL_S='DOMAIN';DOM_SIG_MAIL_N='ADMIN_EMAIL_SIG';
	DOM_NAME_S='DOMAIN';DOM_NAME_N='NAME';


{
	// Constantes en dur dans le moteur de script...
	clSync_sendmail_never = 0; // pas de mail
	clSync_sendmail_on_error =  1; // mail si erreur de synchro seulement
	clSync_sendmail_always =  2; // mail sur toutes les synchros
}


	// Délimiteur dans le template rsyncd.conf
	RSYNCD_TEMLPLATE_DELIM='##';
	// Nom du fichier template rsyncd.conf
	RSYNCD_TEMPLATE_NAME='rsyncd.conf.template'; //path relative au script en cours...

	// Répertoire temporaire pour les synchros (création éventuelle par cette procédure)
	DIRDB_TEMPDIR='desttemp';
	// Permissions sur les répertoires des bases
	DIRDB_PERMS='2775';
	// Permissions sur les volumes des bases
	DB_PERMS='0664';
	// User/Group propréitaire des répertoires des bases
	DIRDB_USER='firebird';
	DIRDB_GROUP='firebird';
	
	// Versiin minimum de client prise en charge
	// Plus la verison exe, mais la version de protocole (6 = ancienne infra ; 7 pour nouvelle infra)
	VER_MIN_CLIENT_SYNC=7;


	// Noms des fichiers requête et réponse de synchro
	SYNC_FILE_REQUEST='sync_req';
	SYNC_FILE_RESP='sync_resp';

	// suffixe ajouté à LibId pour nommer les modules (sections rsyncd.conf) d'informaiton
	RSYNCD_MOD_INFO='_info';

	// Fichier flag de synchro (positionné dans le répertoire de la base de donnée du client :
	FLAG_SYNC='.sync';

	// Temporisation pour finalisation sauvegarde éventuelle en cours (en sec)
	SAV_TEMPO=2; //Test de présence toute les 2 secondes

	// Nombre de boucle d'attente de temporisation d'attente de finalisation de sauvegarde
	SAV_NB_TEMPO=20	; // Nombre de tests avant erreur

	// La durée maximale d'attente, sera donc $SAV_TEMPO * $SAV_NB_TEMPO, par exemple : 10 * 3 ==> 30 secondes...

	// Fichier flag de synchronisation impossible (si ce fichier flag existe dans un répertoire de bases de données, il sera impossible de synchroniser)
	// Traité directement avec les STATES maintenant...
	//FLAG_NOSYNC='.nosync'

	//Fichier flag de sauvegarde impossible (si ce fichier flag existe dans un répertoire de bases de données, il sera impossible de sauvegarder)
	FLAG_NOSAV='.nosav';

	// Fichier flag d'environnement
	// Plus utilisé...
	//FLAG_ENVOK='.env_ok';

	// Fichier flag identification client
	FLAG_IDENT='.ident';

	// Fichier témoin contenant la taille des volumes en début de transfert (dans le répertoire de production)
	SIZE_ORIG='.sizeorig';

	// Fichier témoin contenant la taille des volumes en fin de transfert (dans le répertoire temporaire) -- Attention doit être utilisé avant redescente des fichiers en production...
	SIZE_TRANSERT='.sizetransfert';

	// Fichier témoin contenant la taille des derniers volumes 
	SIZE_LASTVOL='.sizelastvol';

	// Fichier de liste des volumes
	LSTVOL_FILE='liste.txt';
	
	//# FLAG posé sur le répertoire si la synchro est finalisée et que l'on doit nettoyer
	FLAG_CLEAN='.clean';

	// FLAG terminaison, envoyé en dernier lieu
	FLAG_TERM='.term';

	// FLAG de dernier fichier transmis
	FLAG_END='.end';

	// FLAG de conflit
	FLAG_CONFLIT='.conflit';

	// Ajout version 4 : Fichier contenant le titre de la bilbiothèque (déposé par le client dans le module d'écriture)
	TITRE_FILE='.titre';

	// Répertoire des fichiers rsync partiel
	SYNC_PARTIAL='.partial';

	MAX_LOCK_ATTEMPTS=20;

	// Section flag test pour contrôle conformité rsyncd.conf Ok
	RSYNCD_INI_SEC_CTL='libsyncreq';

var
	// Tableau des erreurs rsync
	SYNC_ERR:THashedStringList;

	// Tableau des versions Client/serveur novasync
	SYNC_VER:THashedStringList;

	// Fichier lock rsyncd.conf
	oFSLock:TFileStream;


{
	Retourne la valeur d'une variable system rsync...
	Variables env rsynd :
		o      RSYNC_MODULE_NAME: The name of the module being accessed.
		o      RSYNC_MODULE_PATH: The path configured for the module.
		o      RSYNC_HOST_ADDR: The accessing host’s IP address.
		o      RSYNC_HOST_NAME: The accessing host’s name.
		o      RSYNC_USER_NAME: The accessing user’s name (empty if no user).
		o      RSYNC_PID: A unique number for this transfer.
		o      RSYNC_REQUEST: (pre-xfer only) The module/path info specified by the user (note that the user can specify multiple source files, so the request can be something like "mod/path1 mod/path2", etc.).
}
Function GetRsyncEnv(Env: String):String;
Begin
	case Env of
		'MODULE_NAME',
		'MODULE_PATH',
		'HOST_ADDR',
		'HOST_NAME',
		'USER_NAME',
		'PID',
		'REQUEST', // pre-xfer only
		'ARG0', 'ARG1','ARG2','ARG3','ARG4','ARG5','ARG6','ARG7','ARG8','ARG9', // pre-xfer only
		'EXIT_STATUS', // post-xfer only
		'RAW_STATUS': // post-xfer only
			Result:=Trim(GetEnvironmentVariable('RSYNC_' + Env));
		Else
			RaiseException(ErTypeMismatch,'Variable d''environnnement RSYNC non reconnue');
	End;
	
End;


function GetErrSyncCode(Code: String):String;
begin
	// Si tableau d'erreur non init, on le fait
	if SYNC_ERR = nil then
	begin
		SYNC_ERR:=THashedStringList.Create;

		SYNC_ERR.add('100' + '=' + 'Conflit de synchronisation (une synchronisation est déjà en cours sur cette bibliothèque et une seule synchronisation peut-être réalisée) - Si vous êtes sur que cela n''est pas le cas, veuillez contacter votre support technique'); // ==> Erreur de sav en cours
		SYNC_ERR.add('101' + '=' + 'Une sauvegarde de la bibliothèque est en cours - Veuillez réessayer ultérieurement'); // ==> Erreur de sav en cours
		SYNC_ERR.add('102' + '=' + 'Versions client/serveur de synchronisation  incompatibles - Veuillez mettre à jour votre client de synchronisation ou contacter votre support technique');      // Ajout en version 4
		SYNC_ERR.add('103' + '=' + 'Impossible de mettre la version serveur à jour - Veuillez contacter votre support technique');     // Ajout en version 4 ==> obsolète : MAJ par message 610
		SYNC_ERR.add('104' + '=' + 'L''espace disque est insuffisant sur le serveur - Veuillez contacter votre support technique');     // Ajout en version 4
		SYNC_ERR.add('105' + '=' + 'La synchronisation est actuellement impossible car une tâche de maintenance est en cours sur le serveur - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété'); // Ajout en version 4
		SYNC_ERR.add('106' + '=' + 'Tous les fichiers n''ont pas été transférés - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété'); // Fichier end non présent

		// Nouveau codes d'erreur pour novasync 6+ (init_sync)
		SYNC_ERR.add('601' + '=' + 'Impossible de trouver une demande préalable de synchronisation correspondante - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('602' + '=' + 'Impossible d''analyser le contenu de la demande de synchronisation envoyée (Identifiant bibliothèque introuvable) - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('603' + '=' + 'L''identifiant de bibliothèque demandé ne correspond pas à celui donné dans la demande de synchronisation - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('604' + '=' + 'Impossible d''analyser le contenu de la demande de synchronisation envoyée (login utilisateur introuvable) - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('605' + '=' + 'Impossible d''analyser le contenu de la demande de synchronisation envoyée (mot de passe utilisateur introuvable) - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		// Obsolète...
		SYNC_ERR.add('606' + '=' + 'Impossible d''analyser le contenu de la demande de synchronisation envoyée (taille de la bibliothèque introuvable) - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('607' + '=' + 'Erreur lors de la connexion au serveur d''application - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété'); 
		SYNC_ERR.add('608' + '=' + 'Erreur lors de l''authentification sur serveur d''application - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété'); 
		SYNC_ERR.add('609' + '=' + 'Accès à la bibliothèque impossible sur le serveur d''application - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('610' + '=' + 'La synchronisation est actuellement désactivée- Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété');
		SYNC_ERR.add('611' + '=' + 'Les signatures des bibliothèques client et serveur ne correspondent pas  - Veuillez contacter votre suport technique');
		SYNC_ERR.add('612' + '=' + 'Les fichiers reçus ne semblent pas être ceux attendus - Merci de tenter une nouvelle synchronisation dans quelques minutes et veuillez contacter votre support technique en cas d''échec répété'); // Vérification MD5 NOVAXEL.FDB
		SYNC_ERR.add('613' + '=' + 'La bibliothèque est actuellement verrouillée car elle est en cours de restauration - Veuillez contacter votre support technique si vous ne savez pas à quoi cela correspond'); // Mode RESTORE
		SYNC_ERR.add('614' + '=' + 'La bibliothèque est en mode "Accès total" (full SAAS) - Il est impossible de synchroniser dans ce mode'); // ACCESS_MODE...

		SYNC_ERR.add('620' + '=' + 'Un des fichiers reçus n''est pas dans un état permettant une exploitation correcte - Veuillez contacter votre support technique'); // lock backup sur le volume...

		// Ajout protocole V8 Erreur Licence FULLTEXT
		SYNC_ERR.add('630' + '=' + 'La licence paramétrée pour ce domaine ne permet pas l''utilisation du mode FULLTEXT - Veuillez contacter votre support technique ou le service commercial'); // Licence FULLTEXT...

		// Erreur technique générique renvoyé au client...
		SYNC_ERR.add('1000' + '=' + 'Erreur technique lors de la synchronisation - Veuillez contacter votre suport technique'); 
		// Code d'erreur indiquant une erreur technique pour laquelle seul l'admin sera prévenu (pas le client)
		SYNC_ERR.add('9999' + '=' + 'Erreur de protocole de synchronisation (tentative d''exploitation hors spécifications...)'); 
	end;

	Result:=iif(
		SYNC_ERR.IndexOfName(Code)=-1,
			'Erreur non identifiée',
			SYNC_ERR.Values[Code]
	);
End;


{
	Renvoie le script de synchronisation associé à une version donnése de client de Synchro
	Tous les scripts de synchro doivent être situés dans le même répertoire (que le script courant)
}
function GetSyncScript(Ver: Integer):String;
Begin
	// Tableau des versions non initialisés; on le fait :
	if SYNC_VER=nil then
	begin
		SYNC_VER:=THashedStringList.Create;

		// On ne traite ceci ici qu'à partir de la version 7 du client (précédent = script bash)
		SYNC_VER.add('7' + '=' + 'rsync_script6.xnov');
		// Version proto 8 = prise en charge FULLTEXT.FDB...
		SYNC_VER.add('8' + '=' + 'rsync_script6.xnov');
	end;

	Result:=iif(
		SYNC_VER.IndexOfName(IntToStr(Ver))=-1,
			'',
			IncludeTrailingPathDelimiter(ExtractFilePath(ExpandFileName(FichierScript()))) + SYNC_VER.Values[IntToStr(Ver)]
	);
End;

{
	Renvoie la velur d'une clé dans une section dans le fichier rsyncd.conf...
}

function GetSyncParam(Section, key:String): String;
var
	IniConf: TiniFile;

Begin
	Try
		IniConf:=TIniFile.Create(RSYNCD_CONF_NAME);
		Result:=IniConf.ReadString(Section, Key, '');
	Except
		Result:='';
	Finally
		if IniConf<> nil then IniConf.Free();

	End;
End;

{
	Initialise la valeur d'une clé dans une section dans le fichier rsyncd.conf...

	Attention, ici on écrit sans lock sur le fichier

	Commentée pour éviter des appels intempestifs
}
{
function SetSyncParam(Section, key, Value:String): boolean;
var
	IniConf: TiniFile;

Begin
	Result:=True;
	Try
		IniConf:=TIniFile.Create(RSYNCD_CONF_NAME);
		IniConf.CacheUpdates:=True;
		IniConf.WriteString(Section, Key, Value);
		IniConf.UpdateFile();
	Except
		Result:=False;
	Finally
		if IniConf<> nil then IniConf.Free();
	End;
End;
}

{
	Permet de libérer les ressources globales de ce script
	Doit être appelé volontairement par les scripts utilisant ce script (mode collaboratir)
}
Procedure FreeRsyncRes;
Begin
	If SYNC_ERR <> Nil Then SYNC_ERR.Free();
	If SYNC_VER <> Nil then SYNC_VER.Free();
	FreeNASRes;
End;

{
	Ouverture d'un fichier de requête de synchro
	Renvoi un TStringList contenant chaque élément de la requête (nettoyé, décrypté, etc.)
	Spec : le fichier requête contient 
	* LibId
	* Login (crypté)
	* password SHA256 (crypté)
	* LibGUID
	* Identification Poste Client (DOMAIN#HOSTNAME#IP#MAC#SESSION#??#username)
	* Clé signature poste client
	* Version protole synchro
	* Version Client
	* Taille
	* Versin Novasync
	* Version Client Cloud
}
Function GetSyncReqItem(SynqReqFile: String):TStringList;
var
	i: integer;

Begin
	Result:=TstringList.Create();

	Try
		Result.LoadFromFile(SynqReqFile);
		// Netoyage des entrées
		for i:=0 to Result.count-1 do
			Result[i]:=trim(Result[i]);
		
		Result[1]:=NovDecrypt(Result[1]); // Login
		Result[2]:=NovDecrypt(Result[2]); // Password SHA
	Except
		RaiseException(erCustomError, '601');
		Result.Free();
		Result:=nil;
		exit;
	End;

End;


{
	Connexion globale (ie login) au NAS avec les éléments donnése
	Attention, password doit être fourni en hashed string...
}
function SyncNASConnect(NAS_HOST, Login, password,logfile:string):TNasDomClient;
Var
	CALLER:String;
Begin

	CALLER:='SyncNASConnect';
	Result:=TNasDomClient.Create();
	
	// Test de connexion serveur NAS
	if logfile <>'' then logger('Connexion au NAS "' + NAS_HOST + '"', CALLER, LOG_DEBUG, LogFile);
	if not NASConnect(Result, NAS_HOST) then
	begin
		if logfile <>'' then logger('607 : Connexion serveur NAS "' + NAS_HOST +'" impossible  - Erreur : ' + Result.Errcode + ':' + Result.Errmsg, CALLER, LOG_ERROR, LogFile);
		RaiseException(erCustomError, '607');
	end;
	if logfile <>'' then logger('Connexion OK', CALLER, LOG_DEBUG, LogFile);

	//Connexion sur le domain (en tant qu'utilisateur propriétaire de la bibliothèque)
	if logfile <>'' then logger('Login sur NAS "' + NAS_HOST + '" en tant que "' + Login +'"', CALLER, LOG_DEBUG, LogFile);
	if not NASLogin(Result, Login, Password, true) then
	begin
		if logfile <>'' then logger('608 : Login impossible sur le NAS - Erreur : ' + Result.Errcode + ':' + Result.Errmsg, CALLER, LOG_ERROR, LogFile);
		RaiseException(erCustomError, '608');
	end;
	if logfile <>'' then logger('Login OK', CALLER, LOG_DEBUG, LogFile);
End;


{
	Ouverture du fichier principal de conf en mode "exclusif" (pour pouvoir écrire en accès multiple)
	Idée de JMB ;-)
	On crée un fichier lock qui permet de vérifier qu'aucun autre processus puisse écrire dans le fichier rsyncd.conf en même temps que nous
	Attention, il faut penser à libérer ce fichier lock après intervention...
}

function LockIni(logfile:String):TIniFile;
var
	i:Integer;
	openOk:Boolean;
	IniConf:TIniFile;
	CALLER:String;

Begin

	CALLER:='LockIni';
	i:=1;
	Result:=Nil;

	if logfile <>'' then logger('Tentative d''accès "Exclusif" au fichier "' + RSYNCD_CONF_NAME + '"', CALLER, LOG_DEBUG, LogFile);
	while (not openOk) and (i<MAX_LOCK_ATTEMPTS) do
	Begin
		try
// 			writeln('i='+inttostr(i));  
			// on copie le conf dans un fichier lock qui sera verrouillé
			// (on pourrait aussi créer un fichier lock vide)
			//copyFile(FILESPATH+'rsyncd.conf', FILESPATH+'rsyncd.conf.lock');
			//if logfile <>'' then logger(IncludeTrailingPathDelimiter(GetTempDir) + ExtractFileName(RSYNCD_CONF_NAME) + '.lock', CALLER, LOG_DEBUG, LogFile);

			// Contourneent de bug création fichier vide, on copie le rsyncd.conf existant
			copyFile(RSYNCD_CONF_NAME, IncludeTrailingPathDelimiter(GetTempDir) + ExtractFileName(RSYNCD_CONF_NAME) + '.lock');
			oFSLock:=TFileStream.create(IncludeTrailingPathDelimiter(GetTempDir) + ExtractFileName(RSYNCD_CONF_NAME) + '.lock', fmOpenWrite or fmShareExclusive); // or fmShareExclusive
	// 		writeln('apres create');
			Result:=TIniFile.Create(RSYNCD_CONF_NAME);

			// Test de conformité du rsyncd.conf : on cherche une section particulière dans le fichier ouvert, si non trouvé, fichier inexploitable...
			if logfile <>'' then logger('Test de conformité du fichier "' + Result.Filename + '" (avec la clé "' + RSYNCD_INI_SEC_CTL + '") : ' + BoolToStr(Result<>Nil, BOOLSTR), CALLER, LOG_DEBUG, LogFile);

			if (Result.ReadString(RSYNCD_INI_SEC_CTL, 'path','') = '') then // Path devrait toujours être présent dans notre contexte...
			Begin
				// Erreur gérée par l'appelant...
				if logfile <>'' then logger('Le fichier "' + Result.Filename + '" est altéré (vide ou section "' + RSYNCD_INI_SEC_CTL + '" incomplète ou manquante)', CALLER, LOG_DEBUG, LogFile);
				result:=nil;
				result.Free(); 
				Exit;
			End
			Else
				if logfile <>'' then logger('Le fichier "' + Result.Filename + '" est conforme lors de son ouverture...', CALLER, LOG_DEBUG, LogFile);


			openOk:=true;
			if logfile <>'' then logger('Accès obtenu après ' + Int64ToStr(i) + ' tentatives', CALLER, LOG_DEBUG, LogFile);
		except
// 			writeln('open KO');
			if logfile <>'' then logger('Echec de verrouillage : ' + ExceptionParam, CALLER, LOG_DEBUG, LogFile);
			sleep(1000);
		end;
		i := i + 1;
	End;
End;



Function UnLockIni(logfile:String):Boolean;
Var
	CALLER:String;

Begin

	CALLER:='UnLockIni';
	Result:=False;
	if logfile <>'' then logger('Libération du fichier verrou ', CALLER, LOG_DEBUG, LogFile);
	if oFSLock<>Nil then oFSLock.Free();
	result:=True;
End;


{
	Vérification de la conformité du rsyncd.conf
}
Function CheckRsyncdOk(logfile:string):Boolean;
var
	CALLER:String;
begin
	CALLER:='CheckRsyncdOk';

	result:=false;

	try
		result:=GetSyncParam(RSYNCD_INI_SEC_CTL,'path') <> '';

	Except
		if logfile <>'' then logger('Erreur lors du Test de conformité du fichier "' + RSYNCD_CONF_NAME + '" (avec la clé "' + RSYNCD_INI_SEC_CTL + '") : ' + ExceptionParam, CALLER, LOG_ERROR, LogFile);

	Finally

		if logfile <>'' then logger('Test de conformité du fichier "' + RSYNCD_CONF_NAME + '" (avec la clé "' + RSYNCD_INI_SEC_CTL + '") : ' + BoolToStr(result, BOOLSTR), CALLER, LOG_DEBUG, LogFile);

		if (not result) then
		Begin
			if logfile <>'' then logger('Fichier "' + RSYNCD_CONF_NAME + '" non conforme : on essaie de copier le modèle en cours vers la destination', CALLER, LOG_INFO, LogFile);
			if FileExists(IncludeTrailingPathDelimiter(ExtractFilePath(FichierScript())) + ExtractFileName(RSYNCD_CONF_NAME)) then
			Begin
				if logfile <>'' then logger('Fichier modèle existant, on tente une copie...', CALLER, LOG_DEBUG, LogFile);
				if not CopyFile(IncludeTrailingPathDelimiter(ExtractFilePath(FichierScript())) + ExtractFileName(RSYNCD_CONF_NAME), RSYNCD_CONF_NAME) then
					if logfile <>'' then logger('Impossible de copier le fichier modèle...', CALLER, LOG_ERROR, LogFile)
				else
					if logfile <>'' then logger('Copie du fichier modèle "' + IncludeTrailingPathDelimiter(ExtractFilePath(FichierScript())) + ExtractFileName(RSYNCD_CONF_NAME) + '" vers "' + RSYNCD_CONF_NAME + '" effectué ; les prochaines synchro devraient être Ok', CALLER, LOG_ERROR, LogFile);
			End;

		End;
	End;

end;

{
	Nettoie les fichiers de configuration rsync avant/après synchro
	sLibId doit être passé telle qu'existant dans le fichier de config (ie. paddée avec des 0 le cas échéant)
}
Function NetRsyncParam(sLibID,login,logfile:string):boolean;
var
	Items:TstringList;
	IniTemplate, IniConf:TIniFile;
	Section:String;
	i: integer;
	CALLER:String;
Begin

	CALLER:='NetRsyncParam';

	if logfile <>'' then logger('Appel de "' + CALLER + '" avec les paramètres : sLibId = "' + SLibID + '" - Login : "' + Login + '"', CALLER, LOG_DEBUG, LogFile);

	Try
		Result:=True;

		// Suppression des sections en rsyncd.conf...
		Items:=TstringList.create();
		IniTemplate:=TIniFile.Create(IncludeTrailingPathDelimiter(ExtractFilePath(FichierScript())) + RSYNCD_TEMPLATE_NAME);
		IniTemplate.ReadSections(Items);

// 		IniConf:=TIniFile.Create(RSYNCD_CONF_NAME);
		IniConf:=LockIni(logfile);
		if IniConf=Nil then
		Begin
			if logfile <>'' then logger('Impossible d''obtenir un accès en écriture à ' + RSYNCD_CONF_NAME, CALLER, LOG_DEBUG, LogFile);
			RaiseException(erCustomError, '1000');
		End;


		IniTemplate.CacheUpdates:=true;
		IniConf.CacheUpdates:=True;

		for i:=0 to Items.count-1 do
		begin
			Section:=ReplaceRegExpr('(.*)' + RSYNCD_TEMLPLATE_DELIM + '(.*)' + RSYNCD_TEMLPLATE_DELIM +'(.*)', Items[i],'${1}' + slibID + '${3}',true);
			if logfile <>'' then logger('Suppression (inconditionnelle si existante) de la section "' +  Section + '"', CALLER, LOG_DEBUG, LogFile);
			IniConf.EraseSection(Section);
		End;

		IniTemplate.CancelFile(); // Annule les modifications apportées accidentellement sur IniTemplate
		IniConf.UpdateFile(); // Valide les modifications apportées à IniConf


		// Suppression d'un existant en rsyncd.secret...
		Items.Clear;
		Items.NameValueSeparator:=':';
		Items.loadFromFile(RSYNCD_CONF_SECRET);

		// Suppression d'un secret existant
		i:= Items.IndexOfName(Login);
		if i <> -1 then 
		Begin
			if logfile <>'' then logger('Authentification déjà existante dans "' + RSYNCD_CONF_SECRET + '" ; on la supprime', CALLER, LOG_DEBUG, LogFile);
			Items.delete(i);
		End;

		Items.SaveToFile(RSYNCD_CONF_SECRET);

	Except
		Result:=False;
		IniTemplate.CancelFile();
		IniConf.CancelFile();

	Finally
		if Items<> nil then Items.Free();
		if IniTemplate <> nil then IniTemplate.Free();
		if IniConf <> nil then IniConf.Free();

		UnLockIni(logfile);

		// Test de conformité après MAJ
		If (not CheckRsyncdOk(logfile)) then
		Begin
			if logfile <>'' then logger('1000 : le fichier "' + RSYNCD_CONF_NAME + '" n''est plus conforme après le nettoyage des sections', CALLER, LOG_ERROR, LogFile);
			Result:=False;
			RaiseException(erCustomError, '1000');
		End;

	End;
End;


Function AddSyncLog(
	oNasDomClient:TNasDomClient;
	LibId:Integer;
	TimesStart, TimeEnd:TDateTime;
	logfile:string;
	volorig:Int64;
	voldest:Int64;
	State:boolean;
	Comment: String // '0' ou '' si Ok...
):boolean;
Var
	oLogSync:TLogSync;

	CALLER:String;

Begin
	CALLER:='AddSyncLog';

	Result:=True;
	
	if logfile <>'' then logger('Appel de "' + CALLER + '" avec les paramètres : LibId = "' + IntToStr(LibID) + '"', CALLER, LOG_DEBUG, LogFile);

//	logger('Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  VOL_DEST + '"', CALLER, LOG_DEBUG, LogFile);

	Try
		// Connection obligatoire pour pouvoir journaliser
		if not oNasDomClient.loggedOwner.logged then
		Begin
			Result:=False;
			if logfile <>'' then logger('L''objet TNasDomClient passé n''est pas correctement initialisé (login non effectué)', CALLER, LOG_WARNING, LogFile);
			exit;
		End;

		
		oLogSync:=TLogSync.create(oNasDomClient);

		oLogSync.Library_Id:=libId;
		// Date du fichier de requête de synchro (devrait toujours être présent si nous sommes là...
		oLogSync.time_start:=TimesStart;
		oLogSync.time_end:=TimeEnd;
		oLogSync.size_before:=volorig;
		oLogSync.size_after:=voldest;
		oLogSync.syncState:=State;
		oLogSync.ErrComment:=Comment;

		if not oNasDomClient.add_logsync(oLogSync) then
		begin
			Result:=False;
			if logfile <>'' then logger('Erreur lors de l''enregistrement de la journalisation - Erreur : ' + oNasDomClient.Errcode + ' : ' + oNasDomClient.Errmsg, CALLER, LOG_WARNING, LogFile);
			exit;
		end
		Else
			if logfile <>'' then logger('Enregistrement de journalisation OK', CALLER, LOG_DEBUG, LogFile);

	Finally
		if oLogSync<>nil then oLogSync.Free();
	End;
End;


// Enregistrement d'une journalisation de synchro dans TLOGSYNC
// Rappel : la mise à jour de lib.LastLogSync est effectuée par un trigger dans la base
Function LogSync(oNasDomClient:TNasDomClient;LibId:Int64;dirbase:String;state:boolean; Comment,LogFile:String):boolean;
Var
	CALLER:String;
	SizeOrig, SizeDest, SizeTransfert, SizeLastVol:Int64;
	FileSyncReq:String;

Begin

	Result:=True;

	CALLER:='LogSync';

	if not oNasDomClient.loggedOwner.logged then
	Begin
		if logfile <>'' then Logger('L''objet oNasDomClient passé n''est pas correctement instancié (non connecté)',CALLER ,LOG_ERROR, LogFile);
		RaiseException(erCustomError, '1000');
	End;

	if dirbase<>'' then
	Begin
		FileSyncReq:=IncludeTrailingPathDelimiter(dirbase) + DIRDB_TEMPDIR + clPathDelim + SYNC_FILE_REQUEST + '.' + IntToStr(LibId);

		Try
			SizeOrig:=StrToInt64(trim(LitFichier(IncludeTrailingPathDelimiter(dirbase) + SIZE_ORIG)));
		Except
			// Fichier de stockage  non déposé (erreur lors de la synchro)
			if logfile <>'' then logger('Erreur lors de la lecture du contenu du fichier "' + IncludeTrailingPathDelimiter(dirbase) + SIZE_ORIG + '" : ' + ExceptionParam + ' ; on prend en compte la taille des volumes du répertoire de base "'  + dirbase + '"',CALLER ,LOG_WARNING, LogFile);
			SizeOrig:=GetVolNovaDirSize(dirbase);
		End;
		if logfile <>'' then logger('Taille d''origine : ' + Int64ToStr(SizeOrig) ,CALLER ,LOG_DEBUG, LogFile);

		Try
			SizeTransfert:=StrToInt64(trim(LitFichier(IncludeTrailingPathDelimiter(dirbase) + SIZE_TRANSERT)));
		Except
			// Fichier de stockage  non déposé (erreur lors de la synchro)
			if logfile <>'' then logger('Erreur lors de la lecture du contenu du fichier "' + IncludeTrailingPathDelimiter(dirbase) + SIZE_TRANSERT + '" : ' + ExceptionParam + ' ; on prend en compte la taille des volumes du répertoire de base "'  + IncludeTrailingPathDelimiter(dirbase) + DIRDB_TEMPDIR + '"',CALLER ,LOG_WARNING, LogFile);
			SizeTransfert:=GetVolNovaDirSize(IncludeTrailingPathDelimiter(dirbase) + DIRDB_TEMPDIR);
		End;
		if logfile <>'' then logger('Taille des fichiers déposés : ' + Int64ToStr(SizeTransfert) ,CALLER ,LOG_DEBUG, LogFile);

		Try
			SizeLastVol:=StrToInt64(trim(LitFichier(IncludeTrailingPathDelimiter(dirbase) + SIZE_LASTVOL)));
		Except
			// Fichier de stockage  non déposé (erreur lors de la synchro)
			if logfile <>'' then logger('Erreur lors de la lecture du contenu du fichier "' + IncludeTrailingPathDelimiter(dirbase) + SIZE_LASTVOL + '" : ' + ExceptionParam + ' ; on prend en compte la taille des derniers volumes du répertoire de base "'  + IncludeTrailingPathDelimiter(dirbase) + DIRDB_TEMPDIR + '"',CALLER ,LOG_WARNING, LogFile);
			SizeLastVol:=GetFileSize(IncludeTrailingPathDelimiter(dirbase) + VOL_PRINC) + GetFileSize(GetLastVolume(dirbase));
		End;
		if logfile <>'' then logger('Taille des derniers volumes (avant transfert) : ' + Int64ToStr(SizeLastVol) ,CALLER ,LOG_DEBUG, LogFile);

		// Si des fichiers déposés, on pondère sizetransfert avec la taille des volumes d'origine
		if SizeTransfert<>0 then
		Begin
			SizeDest:=SizeOrig 
				- SizeLastVol
				+ SizeTransfert
		End
		// Sinon, aucun fichier déposé, on dit que la taille finale est la même que celle d'origine (donc taille de transfert = 0)
		else
			SizeDest:=SizeOrig;

		if logfile <>'' then logger('Taille finale enregistrée en log : ' + Int64ToStr(SizeDest) ,CALLER ,LOG_DEBUG, LogFile);
	End
	Else
	// Pas de dirbase passé (peut ne pas être encore mis en place lors de l'appel), on init les tailles à 0 (pas d''existant)
	Begin
		SizeOrig:=0;
		SizeDest:=0;
	End;
		
		
	if not state then comment:=comment + ' (voir le fichier "' + logfile + '" pour plus d''informations)';

	if not AddSyncLog(
		oNasDomClient,
		LibId,
		GetFileDate(FileSyncReq), // Date du fichier de requête de synchro (toujours présent)
		now, // On considère que la syncho est finalisée au moment de l'appel...
		logfile,
		SizeOrig,
		SizeDest,
		state,
		Comment) then
	Begin
		if logfile <>'' then logger('Journalisation de synchro KO', CALLER ,LOG_WARNING, LogFile);
		Result:=False;
	End;
End;

Function sendmailSync(oNasDomClient:TNasDomClient;LibId:Int64;state,AdminOnly:boolean;ErrMsg:String;LogFile:String):boolean;
Var
	CALLER:String;
	LstVar:TStringList;
	LstDest:TStringList;

	ParserDelim:String;
	ValParam:String;

	AdminAddress:String;

	Body, subject:String;
	ValBlb:TStringStream;
	ErrSendMail:Tstrings;
	i,j:Integer;
	ocontType:TContType;
	oLib:TLibrary;
	OOwner:TOwner;
	OFBServer:TFBServer;

	LstContLib:String;

//	oDomParam:TDomParam;


Begin
	CALLER:='sendmailSync';

	if logfile <>'' then logger('Appel de "' + CALLER + ' ErrMsg : "' + ErrMsg + '"', CALLER, LOG_INFO, LogFile);

	Result:=True;

	Try

		if (not (oNasDomClient.loggedOwner.logged or oNasDomClient.loggedOwner.isadmin)) then
		Begin
			if logfile <>'' then logger('L''objet oNasDomClient passé n''est pas correctement instancié (non connecté ou n''est pas un administrateur)',CALLER ,LOG_ERROR, LogFile);
			RaiseException(erCustomError, '1000');
		End;

		NASGetDomParamValues(oNasDomClient, 'DOMAIN','MACRO_DELIM',ParserDelim,Nil);
		ParserDelim:=trim(ParserDelim);
		if ParserDelim='' then
		begin
			logger('Impossible de récupérer la valeur du délimiteur de Macro en TDOMPARAM : ' + oNasDomClient.Errcode + ' : ' + oNasDomClient.Errmsg + ' - utilisation de "' + VAR_MAIL_DELIM + '"', CALLER, LOG_WARNING, LogFile);
			ParserDelim:=VAR_MAIL_DELIM;
		end
		Else
			logger('Delim MAcro : "' + ParserDelim + '"', CALLER, LOG_DEBUG, LogFile);

		oLib:=NASGetLib(oNasDomClient,libId);

		if oLib = nil then
		begin
			if logfile <>'' then logger('609 : Erreur Accès Library : ' + oNasDomClient.Errcode + ':' + oNasDomClient.Errmsg, CALLER, LOG_ERROR, LogFile);
			RaiseException(erCustomError, '609');
		end;

		// On s'occupe de l'admin dans un premier temps
		// Adresse email Admin, recherchée dans le contact principal
		AdminAddress:=oNasDomClient.loggedOwner.contact.email;
		// Si non trouvée, on essaie de récupérer l'adresse générale
		if AdminAddress='' then 
		Begin
			if logfile <>'' then logger('Adresse contact admin vide, on essaie avec le paramètre général: "' + oNasDomClient.DomainAdminEmail + '"', CALLER, LOG_DEBUG, LogFile);
			AdminAddress:=oNasDomClient.DomainAdminEmail;
		End;
		
		if AdminAddress='' then 
		Begin
			if logfile <>'' then logger('Adresse admin param domain inexistante, on prend par défaut l''addresse déclarée en constante : "' + ADMIN_MAIL + '"', CALLER, LOG_DEBUG, LogFile);
			AdminAddress:=ADMIN_MAIL;
		End;
		if logfile <>'' then logger('Adresse admin finale : "' + AdminAddress + '"', CALLER, LOG_DEBUG, LogFile);

		// On récupère les variables identifiées
		if logfile <>'' then logger('Récupération des variables nécessaires au traitement des mails', CALLER, LOG_DEBUG, LogFile);

		LstVar:=TStringList.Create();

		LstVar.add('admin_email' + '=' + AdminAddress);

		// V32 : lib_title
		LstVar.add('lib_title' + '=' + oLib.Title);
		LstVar.add('lib_id' + '=' + IntToStr(LibId));
		LstVar.add('lib_comment' + '=' + trim(oLib.comment));
		LstVar.add('lib_createdate' + '=' + FormatDateTime('dd/mm/yyyy hh:mm',oLib.create_date));
		LstVar.add('lib_modifdate' + '=' + FormatDateTime('dd/mm/yyyy hh:mm',oLib.modif_date));

		LstVar.add('sync_date' + '=' + FormatDateTime('dd/mm/yyyy hh:mm',now));
		// V32 : sync_error
		LstVar.add('sync_error' + '=' + ErrMsg);
		LstVar.add('sync_log' + '=' + LogFile);

		LstVar.add('domain_name' + '=' + trim(oNasDomClient.DomainName));
		LstVar.add('domain_ServerType' + '=' + trim(oNasDomClient.ServerType));
		LstVar.add('domain_ServerVersion' + '=' + trim(oNasDomClient.ServerVersion));
		LstVar.add('domain_DomainVersion' + '=' + trim(oNasDomClient.DomainVersion));
		LstVar.add('domain_Encrypted' + '=' + BoolToStr(oNasDomClient.Encrypted,BOOLSTR));

		OOwner:=NASGetOwner(oNasDomClient,oLib.Owner_Id);
		LstVar.add('owner_id' + '=' + Int64ToStr(oLib.Owner_Id));
		LstVar.add('owner_subdomain' + '=' + trim(OOwner.Subdomain));
		// TODO : à revoir car ce n'est plus le loggedOwner qu'il faut récupérer...
		LstVar.add('owner_name' + '=' + trim(OOwner.Name));
		LstVar.add('owner_firstname' + '=' + trim(OOwner.contact.FirstName));
		LstVar.add('owner_lastname' + '=' + trim(OOwner.contact.Name));
		LstVar.add('owner_prefix' + '=' + trim(OOwner.contact.Prefix));
		LstVar.add('owner_email' + '=' + trim(OOwner.contact.Email));
		LstVar.add('owner_tel' + '=' + trim(OOwner.contact.Tel));
		// V32 : owner_celltel
 		LstVar.add('owner_celltel' + '=' + trim(OOwner.contact.cell_tel));
		LstVar.add('owner_modifdate' + '=' + FormatDateTime('dd/mm/yyyy hh:mm',OOwner.modif_date));
		LstVar.add('owner_createdate' + '=' + FormatDateTime('dd/mm/yyyy hh:mm',OOwner.create_date));
		LstVar.add('owner_comment' + '=' + trim(OOwner.comment));

		// Ajout des contacts ayant du recevoir un email d'alerte aussi :
		oLib.contacts.load(True);
		for i:=0 to olib.contacts.count-1  do
		begin
			for j:=0 to olib.contacts[i].ContTypes.count-1 do
			begin 
				oContType:=olib.contacts[i].ContTypes[j];
				// Ajout du contact en fonction de l'état et du type d'email demandé pour le contact
				if (olib.contacts[i].EMail<>'') and
					(
						(GetStateCompare(ocontType.SyncSendmail,'~',clSync_sendmail_always)) or
						((not state) and (GetStateCompare(ocontType.SyncSendmail,'~',clSync_sendmail_on_error)))
					)
				then
				Begin
					// V32 : ajout celltel
					LstContLib:=LstContLib + olib.contacts[i].Prefix + ' ' + olib.contacts[i].FirstName + ' ' + olib.contacts[i].Name + ' (email : ' + ' ' + olib.contacts[i].Email + ' - Tél : ' + ' ' + olib.contacts[i].Tel + ' - Port : ' + ' ' + olib.contacts[i].Cell_Tel  + ')' + CRLF;
				End;
			End;
		End;

		LstVar.add('contacts_lib' + '=' + trim(LstContLib));


		OFBServer:=NASGetFBServer(oNasDomClient, oLib.FBServer_Id);
		LstVar.add('server_name' + '=' + trim(OFBServer.Name));
		LstVar.add('server_hostname' + '=' + trim(OFBServer.Host));


		// Signature à créer en dernier car elle peut contenir des variables elle-même
		ValBlb:=TStringStream.Create('');
		if NASGetDomParamValues(oNasDomClient, DOM_SIG_MAIL_S,DOM_SIG_MAIL_N,ValParam,ValBlb) then
		begin
			logger('Signature Admin: ' + ValBlb.Datastring, CALLER, LOG_DEBUG, LogFile);
			LstVar.add('signature' + '=' + ParseText(trim(ValBlb.Datastring),ParserDelim,LstVar,False));
		End
		Else
			logger('Impossible de récupérer la valeur du paramètre Signature Admin: ' + oNasDomClient.Errcode + ' : ' + oNasDomClient.Errmsg, CALLER, LOG_WARNING, LogFile);

		LstDest:=TStringList.Create();
		// Par défaut seul le contact admin pricnipal (ou équivalent) recevra le mail
		LstDest.add(AdminAddress);

		ValBlb:=TStringStream.Create('');

		// On s'occupe d'envoyer à l'admin
		if state then // Synchro Ok
		Begin
			NASGetDomParamValues(oNasDomClient, SYNC_MAILADMIN_OK_S,SYNC_MAILADMIN_OK_N,ValParam,ValBlb)
			if logfile <>'' then logger('Préparation de l''email OK pour l''admin avec "' + SYNC_MAILADMIN_OK_S + ' - ' + SYNC_MAILADMIN_OK_N + '"', CALLER, LOG_DEBUG, LogFile);
		End
		else
		Begin
			// Synchro avortée, on ajoute les autres contacts admin de type tecnique en destinataire
			oNasDomClient.loggedOwner.contacts.load(True);
			for i:=0 to oNasDomClient.loggedOwner.Contacts.count-1 do
			Begin
				// TODO : vérifier cette règle de gestion...
				if (oNasDomClient.loggedOwner.Contacts[i].email<>'') and (oNasDomClient.loggedOwner.Contacts[i].ContTypes.Find('Technique')<>nil) then
				Begin
					if logfile <>'' then logger('Ajout de "' +  oNasDomClient.loggedOwner.Contacts[i].email + '" en liste des destinataires admin', CALLER, LOG_DEBUG, LogFile);
					LstDest.add(oNasDomClient.loggedOwner.Contacts[i].email);
				End
				Else
				Begin
					if logfile <>'' then logger('Le contact Admin N° ' + Int64ToStr(oNasDomClient.loggedOwner.Contacts[i].Id) + ' à l''adresse  "' + oNasDomClient.loggedOwner.Contacts[i].EMail + '" n''est pas concerné par ce mail', CALLER, LOG_DEBUG, LogFile);
				End;
			End;

			NASGetDomParamValues(oNasDomClient, SYNC_MAILADMIN_KO_S,SYNC_MAILADMIN_KO_N,ValParam,ValBlb)
			if logfile <>'' then logger('Préparation de l''email KO pour l''admin avec "' + SYNC_MAILADMIN_KO_S + ' - ' + SYNC_MAILADMIN_KO_N + '"', CALLER, LOG_DEBUG, LogFile);
		End;

		if trim(ValParam)='' then
		Begin
			if logfile <>'' then logger('Impossible de récupérer le contenu du mail Admin', CALLER, LOG_WARNING, LogFile);
		End
		Else
		Begin


			if trim(ValBlb.Datastring)='' then
			Begin
				if logfile <>'' then logger('Erreur récupération de value blob pour email admin "'  + '' + oNasDomClient.Errcode + ':' + oNasDomClient.Errmsg, CALLER, LOG_WARNING, LogFile);
			End
			Else
			Begin

				subject:=trim(ValParam);
				//{$IFDEF DEBUG} subject:='[DEBUG] ' + subject; {$ENDIF}
				Body:=trim(ValBlb.Datastring);

// 				if logfile <>'' then logger('sujet avant parse : "' + subject + '"', CALLER, LOG_DEBUG, LogFile);
// 				if logfile <>'' then logger('Body avant parse : "' + Body + '"', CALLER, LOG_DEBUG, LogFile);

				if (body = '') or (subject='')  then
				Begin
					if logfile <>'' then logger('Subject et/ou Body est vide', CALLER, LOG_WARNING, LogFile);
				End
				else // Envoie mail...
				Begin
					ErrSendMail:=TStringList.Create();
					subject:=ParseText(subject,ParserDelim,LstVar,False);
					Body:=ParseText(Body,ParserDelim,LstVar,False);
//  					if logfile <>'' then logger('sujet après parse : "' + subject + '"', CALLER, LOG_DEBUG, LogFile);
//  					if logfile <>'' then logger('Body après parse : "' + Body + '"', CALLER, LOG_DEBUG, LogFile);

					if logfile <>'' then logger('Envoi d''email', CALLER, LOG_DEBUG, LogFile);

					
					if not SendMail(
						subject, // Obj
						LstDest, // dest
						Body, // body
						nil, // fichiers
						AdminAddress, // From
						ErrSendMail
						) then
					Begin
						if logfile <>'' then logger('Envoi de mail administrateur avorté : ' + ErrSendMail.Text, CALLER, LOG_WARNING, LogFile);
					End
					Else
					Begin
						if logfile <>'' then logger('Message envoyé', CALLER, LOG_DEBUG, LogFile);
					End;
				End;
					
			End;
		End;

		// Fin des traitements dans ce cas...
		if AdminOnly then exit;

		// On s'occupe maintenant des contacts et des contextes d'envoi de mail (toujours/eulement sur erreur)
		oLib.contacts.load(True);

		ValBlb:=TStringStream.Create('');
		ValParam:='';

		if state then // Synchro Ok
		Begin
			NASGetDomParamValues(oNasDomClient, SYNC_MAILOWNER_OK_S,SYNC_MAILOWNER_OK_N,ValParam,ValBlb)
			if logfile <>'' then logger('Préparation de l''email OK pour les contacts avec "' + SYNC_MAILOWNER_OK_S + ' - ' + SYNC_MAILOWNER_OK_N + '"', CALLER, LOG_DEBUG, LogFile);
		End
		else
		Begin
			NASGetDomParamValues(oNasDomClient, SYNC_MAILOWNER_KO_S,SYNC_MAILOWNER_KO_N,ValParam,ValBlb)
			if logfile <>'' then logger('Préparation de l''email KO pour pour les contacts avec "' + SYNC_MAILOWNER_KO_S + ' - ' + SYNC_MAILOWNER_KO_N + '"', CALLER, LOG_DEBUG, LogFile);
		End;

		if trim(ValParam)='' then 
		Begin
			if logfile <>'' then logger('Impossible de récupérer le contenu du mail pour les contacts', CALLER, LOG_WARNING, LogFile);
		End
		Else		
		Begin
			for i:=0 to olib.contacts.count-1  do
			begin
				for j:=0 to olib.contacts[i].ContTypes.count-1 do
				begin 
					oContType:=olib.contacts[i].ContTypes[j];
					if logfile <>'' then logger('tconttype : "'  + oContType.name + '"', CALLER, LOG_DEBUG, LogFile);
					// Envoi du mail en fonction de l'état et du type d'email demandé pour le contact
					if (olib.contacts[i].EMail<>'') and
						(
							(GetStateCompare(ocontType.SyncSendmail,'~',clSync_sendmail_always)) or
							((not state) and (GetStateCompare(ocontType.SyncSendmail,'~',clSync_sendmail_on_error)))
						)
					then
					Begin

						if trim(ValBlb.Datastring)='' then
						Begin
							if logfile <>'' then logger('Erreur récupération de value blob pour email contact "'  + '' + oNasDomClient.Errcode + ':' + oNasDomClient.Errmsg, CALLER, LOG_WARNING, LogFile);
						End
						Else
						Begin
							if logfile <>'' then logger('Envoi du mail au contact N° ' + Int64ToStr(olib.contacts[i].Id) + ' à l''adresse  "' + olib.contacts[i].EMail + '"', CALLER, LOG_DEBUG, LogFile);
							// V32 : cont => contact...
							LstVar.add('contact_prefix' + '=' + olib.contacts[i].Prefix);
							LstVar.add('contact_firstname' + '=' + olib.contacts[i].FirstName);
							LstVar.add('contact_name' + '=' + olib.contacts[i].name);

							LstDest.clear();
							LstDest.add(olib.contacts[i].EMail);

							subject:=ParseText(ValParam,ParserDelim,LstVar,True);
							//{$IFDEF DEBUG} subject:='[DEBUG] ' + subject; {$ENDIF}
							Body:=ParseText(ValBlb.Datastring,ParserDelim,LstVar,False);
//							if logfile <>'' then logger('sujet après parse : "' + subject + '"', CALLER, LOG_DEBUG, LogFile);
//							if logfile <>'' then logger('Body après parse : "' + Body + '"', CALLER, LOG_DEBUG, LogFile);

							if not SendMail(
								subject, // Obj
								LstDest, // dest
								Body, // body
								nil, // fichiers
								AdminAddress, // From
								ErrSendMail
								) then
							Begin
								if logfile <>'' then logger('Envoi de mail contact avorté : ' + ErrSendMail.Text, CALLER, LOG_WARNING, LogFile);
							End
							Else
							Begin
								if logfile <>'' then logger('Message contact envoyé', CALLER, LOG_DEBUG, LogFile);
							End;
						End;
					End
					Else
					Begin
						if logfile <>'' then logger('Le contact N° ' + Int64ToStr(olib.contacts[i].Id) + ' à l''adresse  "' + olib.contacts[i].EMail + '" n''est pas concerné par ce mail', CALLER, LOG_DEBUG, LogFile);
					End;
				End;
			End;
		End;

	Except
		Result:=False;
		if logfile <>'' then logger('Erreur traitée dans "' + CALLER + '" : ' + ExceptionParam, CALLER, LOG_INFO, LogFile);


	Finally
		if LstVar<>nil then LstVar.Free();
		if LstDest<>nil then LstDest.Free();
		if ValBlb <> nil then ValBlb.Free();
		if ErrSendMail <> nil then ErrSendMail.Free();
//		if oDomParam <> nil then oDomParam.Free();
		if 	ocontType<>nil then 	ocontType.Free();

	End;
	
End;

{
	Nettoyage des fichiers flag déposés par le client et/ou le serveur de synchro
	Dirbase est le répertoire parent de synchro (donc correspondant au module "XXXXXXXXXX_info" rsync)
}
Procedure NetFlags(dirbase:String; LogFile:String);
Var
	CALLER:String;
Begin
	CALLER:='NetFlags';
	
	if LogFile<>'' then logger('Appel de "' + CALLER + '" sur "' + Dirbase + '"', CALLER, LOG_INFO, LogFile);

	// Deletefile ne renvoie pas d'erreur si fichier inexistant

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_SYNC) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + FLAG_SYNC + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + LSTVOL_FILE) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + LSTVOL_FILE + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  FLAG_END) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  FLAG_END + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_TERM) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + FLAG_TERM + '"', CALLER, LOG_WARNING, LogFile);

{
	// Plus utilisé...
	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_ENVOK) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + FLAG_ENVOK + '"', CALLER, LOG_WARNING, LogFile);
}
	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  FLAG_IDENT) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  FLAG_IDENT + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_CLEAN) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + FLAG_CLEAN + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  TITRE_FILE) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + DIRDB_TEMPDIR + clPathDelim +  TITRE_FILE+ '"', CALLER, LOG_WARNING, LogFile);

	Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_SYNC_CRIT); // Peut ne plus exister depuis longtemps ;-) ==> Pas de log

	Deletefile(IncludeTrailingPathDelimiter(Dirbase) + FLAG_CONFLIT); // Peut ne plus exister depuis longtemps ;-) ==> Pas de log

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + SIZE_ORIG) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + SIZE_ORIG + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + SIZE_LASTVOL) then
		if LogFile<>'' then logger('KO Suppression de  : "' + IncludeTrailingPathDelimiter(Dirbase) + SIZE_LASTVOL + '"', CALLER, LOG_WARNING, LogFile);

	if not Deletefile(IncludeTrailingPathDelimiter(Dirbase) + SIZE_TRANSERT) then
		if LogFile<>'' then logger('KO Suppression de : "' + IncludeTrailingPathDelimiter(Dirbase) + SIZE_TRANSERT + '"', CALLER, LOG_WARNING, LogFile);

End;


{
	Ouverture d'un volume FDB pour test d'accessibilité
}
Function GetVolOk(ONasDomCLient:TNasDomClient;FBServerId:int64;VolPath:String; LogFile:String):TStringList;
var
	oFbServer:TFbServer;

	db: TUIBDatabase;
	tr: TUIBTransaction;
	qr: TUIBQuery;
	CALLER:String;

Begin

	CALLER:='GetVolOk';

	oFbServer:=NASGetFBServer(oNasDomClient,FBServerId);
	Result:=TStringList.Create();

	try
		db := TUIBDatabase.create(nil);
		tr := TUIBTransaction.create(nil);

		db.databasename :=VolPath;
		//db.CharacterSet := csISO8859_1;
		db.SQLDialect := 3;
		db.username := oFbServer.FbAdmLogin;;
		db.password := oFbServer.FbAdmPasswd;
		db.connected:=True;
		tr.database := db;

		qr := TUIBQuery.create(nil);
		qr.CachedFetch:=False;
		qr.FetchBlobs:=False;          
		qr.UseCursor:=True;
		qr.transaction:=tr;
		// Une requête au hasard... TODO on devrait pouvoir faire mieux...
		qr.SQL.Text :='SELECT ' + 
			'MON$ODS_MAJOR' + ',' + // TNasDomClient.MinNovaxelODS
			'MON$ODS_MINOR'  + ',' +
			'MON$SQL_DIALECT' + ',' +
			'MON$PAGE_SIZE'  + ',' +
			'MON$PAGES'  + ',' +
			'MON$SHUTDOWN_MODE'  + ',' +
			'MON$READ_ONLY'  + ',' +
			'MON$BACKUP_STATE' +
			' FROM MON$DATABASE WHERE MON$DATABASE_NAME=''' + VolPath + '''';
		qr.open(True);
		while not qr.eof do
		begin
			Result.add('ods' +  '=' + qr.fields.AsString[0] + '.' + qr.fields.AsString[1]);
			Result.add('dialect' +  '=' + qr.fields.AsString[2]);
			Result.add('page_size' +  '=' + qr.fields.AsString[3]);
			Result.add('pages' +  '=' + qr.fields.AsString[4]);
			Result.add('shutdown_mode' +  '=' + qr.fields.AsString[5]);
			Result.add('read_only' +  '=' + qr.fields.AsString[6]);
			Result.add('backup_state' +  '=' + qr.fields.AsString[7]);
			qr.Next;
		End;
			
		qr.Close(etmCommit);


	Except
		if logfile<>'' then Logger('Impossible d''accéder au volume "' + VolPath + '" : erreur : ' + CRLF + ExceptionParam,CALLER,LOG_WARNING,LogFile);
		Result:=Nil;

	Finally
		Try
			if qr<>Nil then qr.free;
			if tr<>Nil then tr.free;
			if db<>Nil then db.free;
		Except
			// On ne fait rien
		End;

	End;
	
End;

{
	
}
function SetNasTaskSync(oLib:TLibrary; State:integer):Boolean;
var
	TaskSync:TNasTask;
Begin
		try
			TaskSync:= TNasTask.create(TNasDomClient(oLib.NasDomClient));
			TaskSync.Library_Id:=oLib.Id;
			TaskSync.Task_name:='Synchro'; // Normalisation ???
			TaskSync.task_state:=State; // Démarrage
			TNasDomClient(oLib.NasDomClient).set_task_state(TaskSync);
			TaskSync.Free();
			Result:=True;
		Except
			Result:=false;
		End;

End;
